__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1586880312166, "brySVG.drawcanvas": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nfrom brySVG.dragcanvas import *\n\nclass NonBezierMixin(object):\n ''\n def setPoint(self,i,point):\n  self.pointList[i]=point\n  self.update()\n  \n def setPoints(self,pointlist):\n  self.pointList=pointlist\n  self.update()\n  \n def movePoint(self,coords):\n  self.setPoint(-1,coords)\n  \nclass PolyshapeMixin(object):\n ''\n def appendPoint(self,point):\n  self.pointList.append(point)\n  self.update()\n  \n def insertPoint(self,index,point):\n  self.pointList.insert(index,point)\n  self.update()\n  self.updatehittarget()\n  \n def deletePoints(self,start,end):\n  del self.pointList[slice(start,end)]\n  self.update()\n  \nclass BezierMixin(object):\n ''\n def setPointset(self,i,pointset):\n  self.pointList[i]=pointset[1]\n  self.pointsetList[i]=pointset\n  self.update()\n  \n def setPointsets(self,pointsetlist):\n  self.pointList=[pointset[1]for pointset in pointsetlist]\n  self.pointsetList=pointsetlist\n  self.update()\n  self.updatehittarget()\n  \n def setPoint(self,i,point):\n  self.pointList[i]=point\n  self.pointsetList=self.getpointsetlist(self.pointList)\n  self.update()\n  \n def setPoints(self,pointlist):\n  self.pointList=pointlist\n  self.pointsetList=self.getpointsetlist(pointlist)\n  self.update()\n  \n def appendPoint(self,point):\n  self.pointList.append(point)\n  self.pointsetList=self.getpointsetlist(self.pointList)\n  self.update()\n  \n def deletePoints(self,start,end):\n  del self.pointList[slice(start,end)]\n  self.pointsetList=self.getpointsetlist(self.pointList)\n  self.update()\n  \n def insertPoint(self,index,point):\n  self.pointList.insert(index,point)\n  if isinstance(self,SmoothBezierMixin):\n   self.pointsetList=self.getpointsetlist(self.pointList)\n  else :\n   L=len(self.pointList)\n   cpoint1,cpoint2=SmoothBezierMixin.calculatecontrolpoints(self,self.pointList[index -1:index+2])\n   \n   self.pointsetList.insert(index,[cpoint1,point,cpoint2])\n   self.pointsetList[index -1][2]=cpoint1\n   self.pointsetList[(index+1)%L][0]=cpoint2\n  self.update()\n  self.updatehittarget()\n  \n def movePoint(self,point):\n  self.pointList[-1]=point\n  self.updatepointsetlist()\n  if len(self.pointList)==2:\n   self.update()\n  elif isinstance(self,(ClosedBezierObject,SmoothClosedBezierObject)):\n   ((x1,x2),(x3,x4),(x5,x6))=self.pointsetList[-2]\n   ((x7,x8),(x9,x10),(x11,x12))=self.pointsetList[-1]\n   ((x13,x14),(x15,x16),(x17,x18))=self.pointsetList[0]\n   self.plist=self.plist[:-16]+[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16]\n   self.plist[4:6]=[x17,x18]\n   self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n  else :\n   ((x1,x2),(x3,x4),(x5,x6))=self.pointsetList[-2]\n   ((x7,x8),(x9,x10),dummy)=self.pointsetList[-1]\n   self.plist=self.plist[:-10]+[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]\n   self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n   \nclass DrawCanvasMixin(object):\n def createObject(self,coords):\n  colour=\"none\"if self.tool in [\"polyline\",\"bezier\",\"smoothbezier\"]else self.fillColour\n  self.mouseOwner=shapetypes[self.tool](pointlist=[coords,coords],linecolour=self.penColour,linewidth=self.penWidth,fillcolour=colour)\n  self.addObject(self.mouseOwner)\n  self.mouseOwner.shapeType=self.tool\n  \n def drawPoint(self,event):\n  if self.tool ==\"select\":return\n  if self.mouseOwner:\n   if isinstance(self.mouseOwner,(PolyshapeMixin,BezierMixin)):\n    coords=self.getSVGcoords(event)\n    self.mouseOwner.appendPoint(coords)\n    print(\"Appended a point\")\n  else :\n   self.startx=self.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n   self.starty=self.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n   coords=self.getSVGcoords(event)\n   self.createObject(coords)\n   \n def endDraw(self,event):\n  if not self.mouseOwner:return\n  svgobj=self.mouseOwner\n  if isinstance(svgobj,(PolyshapeMixin,BezierMixin)):\n   if event.type ==\"dblclick\":\n    svgobj.deletePoints(-2,None )\n    print(\"Deeleted last 2 points\")\n   elif self.mouseDetected:\n    svgobj.deletePoints(-1,None )\n    print(\"Deleted last point\")\n   elif svgobj.pointList[0]==svgobj.pointList[1]:\n    svgobj.deletePoints(None ,1)\n    print(\"deleted first point\")\n  while len(svgobj.pointList)>1 and svgobj.pointList[-1]==svgobj.pointList[-2]:\n   svgobj.deletePoints(-1,None )\n  if len(svgobj.pointList)==1:self.deleteObject(svgobj)\n  self.mouseOwner=None\n  self.mouseMode=MouseMode.EDIT\n  return svgobj\n  \n def createEditHitTargets(self):\n  objlist=list(self.objectDict.values())\n  for obj in objlist:\n   if obj.fixed:continue\n   if hasattr(obj,\"hitTarget\"):continue\n   if hasattr(obj,\"reference\"):continue\n   if isinstance(obj,(PolyshapeMixin,BezierMixin)):\n    newobj=HitTarget(obj,self)\n   else :\n    if obj.style.fill !=\"none\":continue\n    newobj=obj.cloneObject()\n    newobj.reference=obj\n    newobj.style.strokeWidth=10 *self.scaleFactor if self.mouseDetected else 25 *self.scaleFactor\n    newobj.style.opacity=0\n   obj.hitTarget=newobj\n   self.hittargets.append(newobj)\n   self.addObject(newobj)\n   \n def prepareEdit(self,event):\n  if self.selectedObject:self.deselectObject()\n  svgobject=self.getSelectedObject(event.target.id,getGroup=False )\n  if not svgobject or svgobject.fixed:return\n  self.selectedObject=svgobject\n  self.createHandles(svgobject)\n  \n def createHandles(self,svgobject):\n  if isinstance(svgobject,BezierMixin):\n   handles=[]\n   for i,(point0,point1,point2)in enumerate(svgobject.pointsetList):\n    handle=Handle(svgobject,i,point1,\"red\",self)\n    handle.controlHandles=[]\n    ch0=None if point0 is None else ControlHandle(svgobject,i,0,point0,\"green\",self)\n    ch2=None if point2 is None else ControlHandle(svgobject,i,2,point2,\"green\",self)\n    if ch0:\n     ch0.linkedHandle=ch2 if isinstance(svgobject,SmoothBezierMixin)else None\n     handle.controlHandles.append(ch0)\n    if ch2:\n     ch2.linkedHandle=ch0 if isinstance(svgobject,SmoothBezierMixin)else None\n     handle.controlHandles.append(ch2)\n    handles.append(handle)\n   self.handles=GroupObject(handles)\n   self <=self.handles\n   self.controlhandles=GroupObject([ch for handle in handles for ch in handle.controlHandles])\n   self <=self.controlhandles\n  else :\n   self.handles=GroupObject([Handle(svgobject,i,coords,\"red\",self)for i,coords in enumerate(svgobject.pointList)])\n   self <=self.handles\n   \n def movePoint(self,event):\n  x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  dx,dy=x -self.currentx,y -self.currenty\n  if \"touch\"in event.type and abs(dx)<5 and abs(dy)<5:return\n  self.currentx,self.currenty=x,y\n  if self.mouseMode ==MouseMode.DRAW:\n   coords=self.getSVGcoords(event)\n   self.mouseOwner.movePoint(coords)\n  else :\n   if self.mouseMode ==MouseMode.TRANSFORM:dx,dy=x -self.startx,y -self.starty\n   dx,dy=dx *self.scaleFactor,dy *self.scaleFactor\n   self.mouseOwner.movePoint((dx,dy))\n   \n def insertPoint(self,event):\n  if not self.selectedObject:return None ,None\n  try :\n   index=self.objectDict[event.target.id].segmentindex\n  except AttributeError:\n   return None ,None\n  self.deleteObject(self.handles)\n  self.deleteObject(self.controlhandles)\n  clickpoint=self.getSVGcoords(event)\n  svgobject=self.selectedObject\n  svgobject.insertPoint(index,clickpoint)\n  svgobject.updatehittarget()\n  self.createHandles(svgobject)\n  return index,clickpoint\n  \n def endEdit(self,event):\n  if self.selectedObject:\n   self.selectedObject.updatehittarget()\n   if self.handles:self <=self.handles\n   if self.controlhandles:self <=self.controlhandles\n  self.mouseOwner=None\n  \n def deselectObject(self):\n  if not self.selectedObject:return\n  self.deleteHandles()\n  self.mouseOwner=self.selectedObject=self.selectedhandle=None\n  \n def deleteHandles(self):\n  self.deleteObject(self.handles)\n  self.handles=None\n  if isinstance(self.selectedObject,BezierMixin):\n   self.deleteObject(self.controlhandles)\n   self.controlhandles=None\n   \nclass HitTargetSegment(LineObject):\n def __init__(self,pointlist,width,reference,index):\n  LineObject.__init__(self,pointlist,linewidth=width)\n  self.reference=reference\n  self.segmentindex=index\n  self.style.opacity=0\n  \nclass BezierHitTargetSegment(BezierObject):\n def __init__(self,pointsetlist,width,reference,index):\n  BezierObject.__init__(self,pointsetlist,linewidth=width)\n  self.reference=reference\n  self.segmentindex=index\n  self.style.opacity=0\n  \nclass HitTarget(GroupObject):\n def __init__(self,reference,canvas):\n  GroupObject.__init__(self)\n  self.reference=reference\n  self.canvas=canvas\n  self.update()\n  \n def update(self):\n  self.deleteAll()\n  width=10 *self.canvas.scaleFactor if self.canvas.mouseDetected else 25 *self.canvas.scaleFactor\n  if isinstance(self.reference,PolyshapeMixin):\n   pointlist=self.reference.pointList[:]\n   if isinstance(self.reference,PolygonObject):pointlist.append(pointlist[0])\n   for i in range(len(pointlist)-1):\n    segment=HitTargetSegment(pointlist[i:i+2],width,self.reference,i+1)\n    self.addObject(segment)\n  else :\n   pointsetlist=self.reference.pointsetList[:]\n   if isinstance(self.reference,(ClosedBezierObject,SmoothClosedBezierObject)):pointsetlist.append(pointsetlist[0])\n   for i in range(len(pointsetlist)-1):\n    ps0=[None ]+pointsetlist[i][1:]\n    ps1=pointsetlist[i+1][:-1]+[None ]\n    segment=BezierHitTargetSegment([ps0,ps1],width,self.reference,i+1)\n    self.addObject(segment)\n  self.canvas.deleteObject(self)\n  self.canvas.addObject(self)\n  \nclass Handle(PointObject):\n def __init__(self,owner,index,coords,colour,canvas):\n  pointsize=7 if canvas.mouseDetected else 15\n  opacity=0.4\n  strokewidth=3\n  PointObject.__init__(self,coords,colour,pointsize,canvas)\n  self.style.strokeWidth=strokewidth\n  self.style.fillOpacity=opacity\n  self.owner=owner\n  self.index=index\n  self.canvas=canvas\n  self.bind(\"mousedown\",self.select)\n  self.bind(\"touchstart\",self.select)\n  \n def select(self,event):\n  event.stopPropagation()\n  self.canvas.startx=self.canvas.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  self.canvas.starty=self.canvas.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  self.canvas.mouseOwner=self\n  if isinstance(self.owner,BezierMixin):\n   if self.canvas.selectedhandle:\n    for ch in self.canvas.selectedhandle.controlHandles:ch.style.visibility=\"hidden\"\n   for ch in self.controlHandles:ch.style.visibility=\"visible\"\n  self.canvas.selectedhandle=self\n  \n def movePoint(self,offset):\n  self.XY +=offset\n  if isinstance(self.owner,BezierMixin):\n   pointset=[None ,self.XY,None ]\n   for ch in self.controlHandles:\n    ch.XY +=offset\n    pointset[ch.subindex]=ch.XY\n   self.owner.setPointset(self.index,pointset)\n  else :\n   self.owner.setPoint(self.index,self.XY)\n   \nclass ControlHandle(PointObject):\n def __init__(self,owner,index,subindex,coords,colour,canvas):\n  pointsize=7 if canvas.mouseDetected else 15\n  opacity=0.4\n  strokewidth=3\n  PointObject.__init__(self,coords,colour,pointsize,canvas)\n  self.style.fillOpacity=opacity\n  self.style.strokeWidth=strokewidth\n  self.style.visibility=\"hidden\"\n  self.owner=owner\n  self.index=index\n  self.subindex=subindex\n  self.canvas=canvas\n  self.bind(\"mousedown\",self.select)\n  self.bind(\"touchstart\",self.select)\n  \n def select(self,event):\n  event.stopPropagation()\n  self.canvas.startx=self.canvas.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  self.canvas.starty=self.canvas.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  self.canvas.mouseOwner=self\n  \n def movePoint(self,offset):\n  self.XY +=offset\n  pointset=self.owner.pointsetList[self.index]\n  pointset[self.subindex]=self.XY\n  if self.linkedHandle:\n   point=pointset[1]\n   thisoffset=self.XY -point\n   otheroffset=self.linkedHandle.XY -point\n   newoffset=thisoffset *(otheroffset.length()/thisoffset.length())\n   newothercoords=point -newoffset\n   pointset[self.linkedHandle.subindex]=newothercoords\n   self.linkedHandle.XY=newothercoords\n  self.owner.setPointset(self.index,pointset)\n  \nclass LineObject(LineObject,NonBezierMixin):\n pass\n \nclass PolylineObject(PolylineObject,NonBezierMixin,PolyshapeMixin):\n pass\n \nclass PolygonObject(PolygonObject,NonBezierMixin,PolyshapeMixin):\n pass\n \nclass RectangleObject(RectangleObject,NonBezierMixin):\n pass\n \nclass EllipseObject(EllipseObject,NonBezierMixin):\n pass\n \nclass CircleObject(CircleObject,NonBezierMixin):\n pass\n \nclass BezierObject(BezierObject,BezierMixin):\n pass\n \nclass ClosedBezierObject(ClosedBezierObject,BezierMixin):\n pass\n \nclass SmoothBezierObject(SmoothBezierObject,BezierMixin):\n pass\n \nclass SmoothClosedBezierObject(SmoothClosedBezierObject,BezierMixin):\n pass\n \nclass RegularPolygon(RegularPolygon,NonBezierMixin):\n pass\n \nclass CanvasObject(CanvasObject,DrawCanvasMixin):\n pass\n \nshapetypes={\"line\":LineObject,\"polygon\":PolygonObject,\"polyline\":PolylineObject,\n\"rectangle\":RectangleObject,\"ellipse\":EllipseObject,\"circle\":CircleObject,\n\"bezier\":BezierObject,\"closedbezier\":ClosedBezierObject,\"smoothbezier\":SmoothBezierObject,\"smoothclosedbezier\":SmoothClosedBezierObject}\n\n", ["brySVG.dragcanvas"]], "brySVG.dragcanvas": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\nimport time\nfrom browser import document,alert\nimport browser.svg as svg\nfrom math import sin,cos,atan2,pi,hypot\nsvgbase=svg.svg()\nmouseDetected=False\nlasttaptime=0\n\nclass Enum(list):\n def __init__(self,name,string):\n  values=string.split()\n  for i,value in enumerate(values):\n   setattr(self,value,i)\n   self.append(i)\n   \nMouseMode=Enum('MouseMode','NONE DRAG TRANSFORM DRAW EDIT')\nTransformType=Enum('TransformType','NONE TRANSLATE ROTATE XSTRETCH YSTRETCH ENLARGE')\nPosition=Enum('Position','CONTAINS INSIDE OVERLAPS EQUAL DISJOINT')\n\nclass ObjectMixin(object):\n ''\n \n def cloneObject(self):\n  ''\n\n  \n  if isinstance(self,GroupObject):\n   newobject=GroupObject()\n   for obj in self.ObjectList:\n    newobj=obj.cloneObject()\n    newobject.addObject(newobj)\n   return newobject\n  for objecttype in shapetypes.values():\n   if isinstance(self,objecttype):\n    newobject=objecttype()\n    break\n  else :\n   return None\n  if isinstance(self,PointObject):\n   newobject.XY=self.XY\n  else :\n   newobject.pointList=self.pointList[:]\n   if isinstance(self,BezierMixin):newobject.pointsetList=self.pointsetList[:]\n  if hasattr(self,\"angle\"):newobject.angle=self.angle\n  for (key,value)in self.attrs.items():\n   newobject.attrs[key]=value\n  newobject.id=\"\"\n  return newobject\n  \n def updatehittarget(self):\n  hittarget=getattr(self,\"hitTarget\",None )\n  if hittarget:\n   hittarget.pointList=self.pointList\n   if isinstance(self,BezierMixin):hittarget.pointsetList=self.pointsetList\n   hittarget.update()\n   \n def transformedpointlist(self,matrix):\n  ''\n  pt=svgbase.createSVGPoint()\n  newpointlist=[]\n  for point in self.pointList:\n   (pt.x,pt.y)=point\n   pt=pt.matrixTransform(matrix)\n   newpointlist.append(Point((pt.x,pt.y)))\n  return newpointlist\n  \nclass NonBezierMixin(object):\n pass\n \nclass PolyshapeMixin(object):\n pass\n \nclass BezierMixin(object):\n pass\n \nclass SmoothBezierMixin(BezierMixin):\n ''\n def calculatecontrolpoints(self,points):\n  ''\n  [(x1,y1),(x2,y2),(x3,y3)]=points\n  (dx1,dy1)=((x2 -x1),(y2 -y1))\n  (dx3,dy3)=((x2 -x3),(y2 -y3))\n  d1=hypot(dx1,dy1)\n  d2=hypot(dx3,dy3)\n  if d1 ==0 or d2 ==0:return ((x2,y2),(x2,y2))\n  cos1,sin1=dx1 /d1,dy1 /d1\n  cos2,sin2=dx3 /d2,dy3 /d2\n  \n  (c1x,c1y)=(x2 -d1 *(cos1 -cos2)/2,y2 -d1 *(sin1 -sin2)/2)\n  (c2x,c2y)=(x2+d2 *(cos1 -cos2)/2,y2+d2 *(sin1 -sin2)/2)\n  c1=((c1x+x2)/2,(c1y+y2)/2)\n  c2=((c2x+x2)/2,(c2y+y2)/2)\n  return (Point(c1),Point(c2))\n  \nclass LineObject(svg.line,ObjectMixin,NonBezierMixin):\n ''\n def __init__(self,pointlist=[(0,0),(0,0)],style=\"solid\",linecolour=\"black\",linewidth=1,fillcolour=\"none\"):\n  [(x1,y1),(x2,y2)]=pointlist\n  \n  if style ==\"faintdash1\":\n   dasharray=\"10,5\"\n   linecolour=\"grey\"\n  elif style ==\"faintdash2\":\n   dasharray=\"2,2\"\n   linecolour=\"lightgrey\"\n  else :\n   dasharray=None\n   \n  svg.line.__init__(self,x1=x1,y1=y1,x2=x2,y2=y2,style={\"stroke\":linecolour,\"strokeDasharray\":dasharray,\"strokeWidth\":linewidth})\n  self.pointList=[Point(coords)for coords in pointlist]\n  \n def update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  self.attrs[\"x1\"]=x1\n  self.attrs[\"y1\"]=y1\n  self.attrs[\"x2\"]=x2\n  self.attrs[\"y2\"]=y2\n  \nclass TextObject(svg.text):\n ''\n\n\n\n\n \n def __init__(self,string,anchorpoint,anchorposition=1,fontsize=12,style=\"normal\",ignorescaling=False ,canvas=None ):\n  (x,y)=anchorpoint\n  stringlist=string.split(\"\\n\")\n  rowcount=len(stringlist)\n  if anchorposition in [3,6,9]:\n   horizpos=\"end\"\n  elif anchorposition in [2,5,8]:\n   horizpos=\"middle\"\n  else :\n   horizpos=\"start\"\n  lineheight=fontsize *1.2\n  if ignorescaling and canvas:\n   fontsize *=canvas.scaleFactor\n   lineheight *=canvas.scaleFactor\n  if anchorposition in [1,2,3]:\n   yoffset=fontsize\n  elif anchorposition in [4,5,6]:\n   yoffset=fontsize *(1 -rowcount /2)\n  else :\n   yoffset=fontsize *(1 -rowcount)\n   \n  svg.text.__init__(self,stringlist[0],x=x,y=y+yoffset,font_size=fontsize,text_anchor=horizpos)\n  for s in stringlist[1:]:\n   self <=svg.tspan(s,x=x,dy=lineheight)\n   \nclass WrappingTextObject(svg.text):\n ''\n \n def __init__(self,canvas,string,anchorpoint,width,anchorposition=1,fontsize=12,style=\"normal\",ignorescaling=False ):\n  (x,y)=anchorpoint\n  lineheight=fontsize *1.2\n  if ignorescaling:\n   fontsize *=canvas.scaleFactor\n   lineheight *=canvas.scaleFactor\n  words=string.split()\n  svg.text.__init__(self,\"\",x=x,font_size=fontsize)\n  canvas <=self\n  tspan=svg.tspan(words.pop(0),x=x,dy=0)\n  self <=tspan\n  rowcount=1\n  for word in words:\n   tspan.text +=\" \"+word\n   if tspan.getComputedTextLength()>width:\n    tspan.text=tspan.text[:-len(word)-1]\n    tspan=svg.tspan(word,x=x,dy=lineheight)\n    self <=tspan\n    rowcount +=1\n    \n  if anchorposition in [3,6,9]:\n   horizpos=\"end\"\n  elif anchorposition in [2,5,8]:\n   horizpos=\"middle\"\n  else :\n   horizpos=\"start\"\n  self.attrs[\"text-anchor\"]=horizpos\n  if anchorposition in [1,2,3]:\n   yoffset=fontsize\n  elif anchorposition in [4,5,6]:\n   yoffset=fontsize *(1 -rowcount /2)\n  else :\n   yoffset=fontsize *(1 -rowcount)\n  self.attrs[\"y\"]=y+yoffset\n  \nclass PolylineObject(svg.polyline,ObjectMixin,NonBezierMixin,PolyshapeMixin):\n ''\n \n def __init__(self,pointlist=[(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"none\"):\n  svg.polyline.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  self.pointList=[Point(coords)for coords in pointlist]\n  self.update()\n  \n def update(self):\n  self.attrs[\"points\"]=\" \".join([str(point[0])+\",\"+str(point[1])for point in self.pointList])\n  \nclass PolygonObject(svg.polygon,ObjectMixin,NonBezierMixin,PolyshapeMixin):\n ''\n \n def __init__(self,pointlist=[(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  svg.polygon.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  self.pointList=[Point(coords)for coords in pointlist]\n  self.update()\n  \n def update(self):\n  self.attrs[\"points\"]=\" \".join([str(point[0])+\",\"+str(point[1])for point in self.pointList])\n  \nclass RectangleObject(svg.rect,ObjectMixin,NonBezierMixin):\n ''\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],angle=0,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  svg.rect.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  self.pointList=[Point(coords)for coords in pointlist]\n  self.angle=angle\n  self.update()\n  \n def update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  t=svgbase.createSVGTransform()\n  t.setRotate(self.angle,cx,cy)\n  self.transform.baseVal.initialize(t)\n  self.rotatestring=self.attrs[\"transform\"]\n  \n  basepointlist=self.transformedpointlist(t.matrix.inverse())\n  [(x1,y1),(x2,y2)]=basepointlist\n  self.attrs[\"x\"]=x2 if x2 <x1 else x1\n  self.attrs[\"y\"]=y2 if y2 <y1 else y1\n  self.attrs[\"width\"]=abs(x2 -x1)\n  self.attrs[\"height\"]=abs(y2 -y1)\n  \nclass EllipseObject(svg.ellipse,ObjectMixin,NonBezierMixin):\n ''\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],angle=0,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  svg.ellipse.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  self.pointList=[Point(coords)for coords in pointlist]\n  self.angle=angle\n  self.update()\n  \n def update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  t=svgbase.createSVGTransform()\n  t.setRotate(self.angle,cx,cy)\n  self.transform.baseVal.initialize(t)\n  self.rotatestring=self.attrs[\"transform\"]\n  \n  basepointlist=self.transformedpointlist(t.matrix.inverse())\n  [(x1,y1),(x2,y2)]=basepointlist\n  self.attrs[\"cx\"]=(x1+x2)/2\n  self.attrs[\"cy\"]=(y1+y2)/2\n  self.attrs[\"rx\"]=abs(x2 -x1)/2\n  self.attrs[\"ry\"]=abs(y2 -y1)/2\n  \nclass CircleObject(svg.circle,ObjectMixin,NonBezierMixin):\n ''\n\n \n def __init__(self,centre=(0,0),radius=0,pointlist=None ,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  if pointlist:\n   self.pointList=[Point(coords)for coords in pointlist]\n  else :\n   (x,y)=centre\n   self.pointList=[Point((x,y)),Point((x+radius,y))]\n  svg.circle.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  self.update()\n  \n def update(self):\n  [(x1,y1),(x2,y2)]=self.pointList\n  self.attrs[\"cx\"]=x1\n  self.attrs[\"cy\"]=y1\n  self.attrs[\"r\"]=hypot(x2 -x1,y2 -y1)\n  \nclass BezierObject(svg.path,BezierMixin,ObjectMixin):\n ''\n\n\n\n\n \n def __init__(self,pointsetlist=None ,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"none\"):\n  def toPoint(coords):\n   return None if coords is None else Point(coords)\n  svg.path.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  if pointsetlist:\n   self.pointList=[Point(pointset[1])for pointset in pointsetlist]\n  else :\n   self.pointList=[Point(coords)for coords in pointlist]\n   pointsetlist=self.getpointsetlist(self.pointList)\n  self.pointsetList=[[toPoint(coords)for coords in pointset]for pointset in pointsetlist]\n  self.update()\n  \n def getpointsetlist(self,pointlist):\n  pointsetlist=[[None ,pointlist[0],(pointlist[0]+pointlist[1])/2]]\n  for i in range(1,len(pointlist)-1):\n   pointsetlist.append([(pointlist[i -1]+pointlist[i])/2,pointlist[i],(pointlist[i]+pointlist[i+1])/2])\n  pointsetlist.append([(pointlist[-2]+pointlist[-1])/2,pointlist[-1],None ])\n  return pointsetlist\n  \n def updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=[[None ]+self.pointList,self.pointList+[None ]]\n  else :\n   cpoint=(self.pointList[-1]+self.pointList[-2])/2\n   self.pointsetList[-1]=[cpoint,self.pointList[-1],None ]\n   self.pointsetList[-2][2]=cpoint\n   \n def update(self):\n  (dummy,(x1,y1),(c1x,c1y))=self.pointsetList[0]\n  ((c2x,c2y),(x2,y2),dummy)=self.pointsetList[-1]\n  self.plist=[\"M\",x1,y1,\"C\",c1x,c1y]+[x for p in self.pointsetList[1:-1]for c in p for x in c]+[c2x,c2y,x2,y2]\n  self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n  \nclass ClosedBezierObject(svg.path,BezierMixin,ObjectMixin):\n ''\n\n\n\n \n def __init__(self,pointsetlist=None ,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  svg.path.__init__(self,style={\"stroke\":linecolour,\"strokeWidth\":linewidth,\"fill\":fillcolour})\n  if pointsetlist:\n   self.pointList=[Point(pointset[1])for pointset in pointsetlist]\n  else :\n   self.pointList=[Point(coords)for coords in pointlist]\n   pointsetlist=self.getpointsetlist(self.pointList)\n  self.pointsetList=[[Point(coords)for coords in pointset]for pointset in pointsetlist]\n  self.update()\n  \n def getpointsetlist(self,pointlist):\n  pointsetlist=[[(pointlist[0]+pointlist[-1])/2,pointlist[0],(pointlist[0]+pointlist[1])/2]]\n  for i in range(1,len(pointlist)-1):\n   pointsetlist.append([(pointlist[i -1]+pointlist[i])/2,pointlist[i],(pointlist[i]+pointlist[i+1])/2])\n  pointsetlist.append([(pointlist[-2]+pointlist[-1])/2,pointlist[-1],(pointlist[0]+pointlist[-1])/2])\n  return pointsetlist\n  \n def updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=self.getpointsetlist(self.pointList)\n  else :\n   cpoint1,cpoint2=(self.pointList[-1]+self.pointList[-2])/2,(self.pointList[-1]+self.pointList[0])/2\n   self.pointsetList[-1]=(cpoint1,self.pointList[-1],cpoint2)\n   self.pointsetList[-2][2]=cpoint1\n   self.pointsetList[0][0]=cpoint2\n   \n def update(self):\n  ((c1x,c1y),(x,y),(c2x,c2y))=self.pointsetList[0]\n  self.plist=[\"M\",x,y,\"C\",c2x,c2y]+[x for p in self.pointsetList[1:]for c in p for x in c]+[c1x,c1y,x,y]\n  self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n  \nclass SmoothBezierObject(SmoothBezierMixin,BezierObject):\n ''\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"none\"):\n  self.pointList=[Point(coords)for coords in pointlist]\n  pointsetlist=self.getpointsetlist(self.pointList)\n  BezierObject.__init__(self,pointsetlist,linecolour=linecolour,linewidth=linewidth,fillcolour=fillcolour)\n  \n def getpointsetlist(self,pointlist):\n  if len(pointlist)==2:return [[None ]+pointlist,pointlist+[None ]]\n  for i in range(1,len(pointlist)-1):\n   (c1,c2)=self.calculatecontrolpoints(pointlist[i -1:i+2])\n   if i ==1:\n    pointsetlist=[[None ,pointlist[0],(pointlist[0]+c1)/2]]\n   pointsetlist.append([c1,pointlist[i],c2])\n  pointsetlist.append([(pointlist[-1]+c2)/2,pointlist[-1],None ])\n  return pointsetlist\n  \n def updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=[[None ]+self.pointList,self.pointList+[None ]]\n  else :\n   (c1,c2)=self.calculatecontrolpoints(self.pointList[-3:])\n   self.pointsetList[-1]=[(self.pointList[-1]+c2)/2,self.pointList[-1],None ]\n   self.pointsetList[-2]=[c1,self.pointList[-2],c2]\n   \nclass SmoothClosedBezierObject(SmoothBezierMixin,ClosedBezierObject):\n ''\n\n\n \n def __init__(self,pointlist=[(0,0),(0,0)],linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  self.pointList=[Point(coords)for coords in pointlist]\n  pointsetlist=self.getpointsetlist(self.pointList)\n  ClosedBezierObject.__init__(self,pointsetlist,linecolour=linecolour,linewidth=linewidth,fillcolour=fillcolour)\n  \n def getpointsetlist(self,pointlist):\n  pointlist=[pointlist[-1]]+pointlist[:]+[pointlist[0]]\n  pointsetlist=[]\n  for i in range(1,len(pointlist)-1):\n   (c1,c2)=self.calculatecontrolpoints(pointlist[i -1:i+2])\n   pointsetlist.append([c1,pointlist[i],c2])\n  return pointsetlist\n  \n def updatepointsetlist(self):\n  if len(self.pointList)==2:\n   self.pointsetList=self.getpointsetlist(self.pointList)\n  else :\n   L=len(self.pointList)\n   pointlist=self.pointList[:]+self.pointList[:2]\n   for j in range(L -2,L+1):\n    (c1,c2)=self.calculatecontrolpoints(pointlist[j -1:j+2])\n    self.pointsetList[j %L]=[c1,pointlist[j],c2]\n    \nclass PointObject(svg.circle,ObjectMixin):\n ''\n\n \n def __init__(self,XY=(0,0),colour=\"black\",pointsize=2,canvas=None ):\n  (x,y)=XY\n  sf=canvas.scaleFactor if canvas else 1\n  svg.circle.__init__(self,cx=x,cy=y,r=pointsize *sf,style={\"stroke\":colour,\"strokeWidth\":1,\"fill\":colour})\n  self._XY=None\n  self.XY=Point(XY)\n  \n def update(self):\n  pass\n  \n @property\n def XY(self):\n  return self._XY\n  \n @XY.setter\n def XY(self,XY):\n  self._XY=Point(XY)\n  self.attrs[\"cx\"]=self._XY[0]\n  self.attrs[\"cy\"]=self._XY[1]\n  \nclass RegularPolygon(PolygonObject):\n ''\n\n\n\n \n def __init__(self,sidecount,centre=None ,radius=None ,startpoint=None ,sidelength=None ,offsetangle=0,linecolour=\"black\",linewidth=1,fillcolour=\"yellow\"):\n  angle=2 *pi /sidecount\n  radoffset=offsetangle *pi /180\n  if not radius:radius=sidelength /(2 *sin(pi /sidecount))\n  if not centre:\n   (x,y)=startpoint\n   centre=(x -radius *sin(radoffset),y+radius *cos(radoffset))\n  (cx,cy)=centre\n  self.pointList=[]\n  for i in range(sidecount):\n   t=radoffset+i *angle\n   self.pointList.append(Point((cx+radius *sin(t),cy -radius *cos(t))))\n  PolygonObject.__init__(self,self.pointList,linecolour,linewidth,fillcolour)\n  \nclass GroupObject(svg.g,ObjectMixin):\n ''\n\n \n def __init__(self,objlist=[]):\n  svg.g.__init__(self)\n  if not isinstance(objlist,list):objlist=[objlist]\n  self.ObjectList=[]\n  for obj in objlist:\n   self.addObject(obj)\n  self._Canvas=None\n  self.Group=None\n  \n def addObject(self,svgobject,objid=None ,fixed=False ):\n  self <=svgobject\n  if objid:svgobject.attrs[\"id\"]=objid\n  if not hasattr(svgobject,\"fixed\"):svgobject.fixed=fixed\n  svgobject.Group=self\n  self.ObjectList.append(svgobject)\n  \n def addObjects(self,objectlist,fixed=False ):\n  for obj in objectlist:self.addObject(obj,fixed=fixed)\n  \n def deleteAll(self):\n  while self.firstChild:\n   self.removeChild(self.firstChild)\n  self.ObjectList=[]\n  \n @property\n def canvas(self):\n  return self._canvas\n  \n @canvas.setter\n def canvas(self,canvas):\n  self._canvas=canvas\n  for obj in self.ObjectList:\n   obj.canvas=canvas\n   \nclass Button(GroupObject):\n ''\n \n def __init__(self,position,size,text,onclick,fontsize=None ,fillcolour=\"lightgrey\",objid=None ):\n  GroupObject.__init__(self)\n  if objid:self.id=objid\n  (x,y),(width,height)=position,size\n  self.button=RectangleObject([(x,y),(x+width,y+height)],fillcolour=fillcolour)\n  self.button.attrs[\"rx\"]=height /3\n  rowcount=text.count(\"\\n\")+1\n  if not fontsize:fontsize=height *0.8 /rowcount\n  text=TextObject(text,(x+width /2,y+height /2 -fontsize /6),anchorposition=5,fontsize=fontsize)\n  self.addObjects([self.button,text],fixed=True )\n  self.bind(\"mousedown\",self.onMouseDown)\n  self.bind(\"click\",onclick)\n  self.bind(\"touchstart\",onclick)\n  self.attrs[\"cursor\"]=\"pointer\"\n  \n def onMouseDown(self,event):\n  event.stopPropagation()\n  \n def setBackgroundColour(self,colour):\n  self.button.style.fill=colour\n  \nclass ImageButton(GroupObject):\n ''\n\n \n def __init__(self,position,size,image,onclick,fillcolour=\"lightgrey\",canvas=None ,objid=None ):\n  GroupObject.__init__(self)\n  if objid:self.id=objid\n  (x,y),(width,height)=position,size\n  self.button=RectangleObject([(x,y),(x+width,y+height)],fillcolour=fillcolour)\n  self.button.attrs[\"rx\"]=height /3\n  image.attrs[\"transform\"]=\"translate({},{})\".format(x+width /2,y+height /2)\n  if canvas:\n   canvas <=image\n   bbox=image.getBBox()\n   canvas.removeChild(image)\n   scalefactor=min(width /bbox.width,height /bbox.height)*0.7\n   image.attrs[\"transform\"]+=\" scale({})\".format(scalefactor)\n  self.addObjects([self.button,image],fixed=True )\n  self.bind(\"mousedown\",self.onMouseDown)\n  self.bind(\"click\",onclick)\n  self.bind(\"touchstart\",onclick)\n  self.attrs[\"cursor\"]=\"pointer\"\n  \n def onMouseDown(self,event):\n  event.stopPropagation()\n  \n def setBackgroundColour(self,colour):\n  self.button.style.fill=colour\n  \nclass CanvasObject(svg.svg):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,width,height,colour=\"white\",objid=None ):\n  svg.svg.__init__(self,style={\"width\":width,\"height\":height,\"backgroundColor\":colour})\n  if objid:self.id=objid\n  self.objectDict={}\n  \n  self.mouseMode=MouseMode.DRAG\n  self.transformTypes=TransformType\n  self.snap=None\n  self.rotateSnap=None\n  self.tool=\"select\"\n  self.penColour=\"black\"\n  self.fillColour=\"yellow\"\n  self.penWidth=3\n  \n  \n  self.scaleFactor=1\n  self.mouseDetected=False\n  self.mouseOwner=None\n  self.selectedObject=None\n  \n  \n  self.objectDict={}\n  self.hittargets=[]\n  self.handles=None\n  self.controlhandles=None\n  self.transformHandles=[]\n  self.selectedhandle=None\n  self.transformorigin=None\n  self.transformBBox=RectangleObject(linecolour=\"blue\",fillcolour=\"none\")\n  \n  self.bind(\"mousedown\",self.onMouseDown)\n  self.bind(\"mousemove\",self.onMouseMove)\n  self.bind(\"mouseup\",self.onLeftUp)\n  self.bind(\"touchstart\",self.onTouchStart)\n  self.bind(\"touchmove\",self.onMouseMove)\n  self.bind(\"touchend\",self.onLeftUp)\n  self.bind(\"dragstart\",self.onDragStart)\n  self.bind(\"dblclick\",self.onDoubleClick)\n  document.bind(\"keydown\",self.deleteSelection)\n  \n def setDimensions(self):\n  ''\n  \n  bcr=self.getBoundingClientRect()\n  self.attrs[\"width\"]=bcr.width\n  self.attrs[\"height\"]=bcr.height\n  return bcr.width,bcr.height\n  \n def fitContents(self):\n  ''\n  bbox=self.getBBox()\n  bboxstring=str(bbox.x -10)+\" \"+str(bbox.y -10)+\" \"+str(bbox.width+20)+\" \"+str(bbox.height+20)\n  self.attrs[\"viewBox\"]=bboxstring\n  self.scaleFactor=self.getScaleFactor()\n  \n  \n def getScaleFactor(self):\n  ''\n  \n  bcr=self.getBoundingClientRect()\n  vbleft,vbtop,vbwidth,vbheight=[float(x)for x in self.attrs[\"viewBox\"].split()]\n  return max(vbwidth /bcr.width,vbheight /bcr.height)\n  \n def getSVGcoords(self,event):\n  ''\n  x=event.changedTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.changedTouches[0].clientY if \"touch\"in event.type else event.clientY\n  pt=self.createSVGPoint()\n  (pt.x,pt.y)=(x,y)\n  SVGpt=pt.matrixTransform(self.getScreenCTM().inverse())\n  return Point((SVGpt.x,SVGpt.y))\n  \n def addObject(self,svgobject,objid=None ,fixed=False ):\n  ''\n\n\n  \n  def AddToDict(svgobj,fixed):\n   if not svgobj.id:svgobj.id=\"id\"+str(len(self.objectDict))\n   self.objectDict[svgobj.id]=svgobj\n   if not hasattr(svgobj,\"fixed\"):svgobj.fixed=fixed\n   if isinstance(svgobj,GroupObject):\n    for obj in svgobj.ObjectList:\n     AddToDict(obj,fixed)\n  if objid:svgobject.id=objid\n  self <=svgobject\n  AddToDict(svgobject,fixed)\n  svgobject.canvas=self\n  return svgobject\n  \n def deleteObject(self,svgobject):\n  ''\n  if not self.contains(svgobject):return\n  self.removeChild(svgobject)\n  try :\n   del self.objectDict[svgobject.id]\n  except (AttributeError,KeyError):\n   pass\n   \n def deleteAll(self):\n  ''\n  while self.firstChild:\n   self.removeChild(self.firstChild)\n  self.objectDict={}\n  \n def deleteSelection(self,event):\n  ''\n  if event.keyCode ==46:\n   if self.selectedObject:\n    if self.handles:self.deleteObject(self.handles)\n    if self.controlhandles:self.deleteObject(self.controlhandles)\n    hittarget=getattr(self.selectedObject,\"hitTarget\",None )\n    if hittarget:self.deleteObject(hittarget)\n    self.deleteObject(self.selectedObject)\n    self.selectedObject=self.handles=self.controlhandles=None\n    \n def rotateElement(self,element,angle,centre=None ):\n  ''\n  \n  \n  if not centre:\n   bbox=element.getBBox()\n   centre=(bbox.x+bbox.width /2,bbox.y+bbox.height /2)\n  t=svgbase.createSVGTransform()\n  t.setRotate(angle,*centre)\n  element.transform.baseVal.insertItemBefore(t,0)\n  return t.matrix\n  \n def scaleElement(self,element,xscale,yscale=None ):\n  ''\n  \n  if not yscale:yscale=xscale\n  t=svgbase.createSVGTransform()\n  t.setScale(xscale,yscale)\n  element.transform.baseVal.insertItemBefore(t,0)\n  return t.matrix\n  \n def translateElement(self,element,vector):\n  ''\n  t=svgbase.createSVGTransform()\n  t.setTranslate(*vector)\n  element.transform.baseVal.insertItemBefore(t,0)\n  return t.matrix\n  \n def translateObject(self,svgobject,offset):\n  ''\n  \n  offset=Point(offset)\n  if isinstance(svgobject,GroupObject):\n   for obj in svgobject.ObjectList:\n    self.translateObject(obj,offset)\n  elif isinstance(svgobject,PointObject):\n   svgobject.XY +=offset\n  else :\n   svgobject.pointList=[point+offset for point in svgobject.pointList]\n   if isinstance(svgobject,BezierMixin):\n    svgobject.pointsetList=[(p1+offset,p2+offset,p3+offset)for (p1,p2,p3)in svgobject.pointsetList]\n   svgobject.update()\n   svgobject.updatehittarget()\n   \n   \n @property\n def mouseMode(self):\n  return self._mouseMode\n  \n @mouseMode.setter\n def mouseMode(self,mm):\n  currentmm=getattr(self,\"_mouseMode\",None )\n  if currentmm ==mm:return\n  if currentmm ==MouseMode.TRANSFORM:self.hideTransformHandles()\n  elif currentmm ==MouseMode.EDIT:self.deselectObject()\n  self._mouseMode=mm\n  self.tool=\"select\"\n  if mm in [MouseMode.DRAG,MouseMode.EDIT,MouseMode.TRANSFORM]:\n   try :\n    self.createEditHitTargets()\n   except AttributeError:\n    self.createHitTargets()\n    \n def createHitTargets(self):\n  objlist=list(self.objectDict.values())\n  for obj in objlist:\n   if obj.style.fill !=\"none\"or obj.fixed:continue\n   if hasattr(obj,\"hitTarget\"):continue\n   if hasattr(obj,\"reference\"):continue\n   newobj=obj.cloneObject()\n   newobj.style.strokeWidth=10 *self.scaleFactor if self.mouseDetected else 25 *self.scaleFactor\n   newobj.style.opacity=0\n   newobj.reference=obj\n   obj.hitTarget=newobj\n   self.hittargets.append(newobj)\n   self.addObject(newobj)\n   \n def onRightClick(self,event):\n  event.preventDefault()\n  \n def onDragStart(self,event):\n  event.preventDefault()\n  \n def onTouchStart(self,event):\n  event.preventDefault()\n  global lasttaptime\n  latesttaptime=time.time()\n  if latesttaptime -lasttaptime <0.3:\n   for function in self.events(\"dblclick\"):\n    function(event)\n  else :\n   self.onLeftDown(event)\n  lasttaptime=latesttaptime\n  \n def onMouseDown(self,event):\n  if not self.mouseDetected:\n   self.mouseDetected=True\n   for obj in self.objectDict.values():\n    if hasattr(obj,\"reference\"):\n     obj.style.strokeWidth=10 *self.scaleFactor\n  if event.button >0:return\n  self.onLeftDown(event)\n  \n def onLeftDown(self,event):\n \n  if self.mouseMode ==MouseMode.DRAG:\n   self.prepareDrag(event)\n  elif self.mouseMode ==MouseMode.TRANSFORM:\n   self.prepareTransform(event)\n  elif self.mouseMode ==MouseMode.DRAW:\n   self.drawPoint(event)\n  elif self.mouseMode ==MouseMode.EDIT:\n   self.prepareEdit(event)\n   \n def onMouseMove(self,event):\n  event.preventDefault()\n  if not self.mouseOwner:return\n  if self.mouseMode ==MouseMode.DRAG:\n   self.doDrag(event)\n  else :\n   self.movePoint(event)\n   \n def onLeftUp(self,event):\n  if event.type ==\"mouseup\"and event.button >0:return\n  if not self.mouseOwner:return\n  if self.mouseMode ==MouseMode.DRAG:\n   self.endDrag(event)\n  elif self.mouseMode ==MouseMode.TRANSFORM:\n   self.endTransform(event)\n   self.mouseOwner=None\n  elif self.mouseMode ==MouseMode.EDIT:\n   self.endEdit(event)\n   \n def onDoubleClick(self,event):\n  if self.mouseMode ==MouseMode.DRAW:self.endDraw(event)\n  \n def prepareDrag(self,event):\n  self.selectedObject=self.getSelectedObject(event.target.id)\n  if self.selectedObject and not self.selectedObject.fixed:\n   self.mouseOwner=self.selectedObject\n   self <=self.mouseOwner\n   self.StartPoint=self.getSVGcoords(event)\n   self.startx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n   self.starty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n   \n def doDrag(self,event):\n  x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  dx,dy=(x -self.startx)*self.scaleFactor,(y -self.starty)*self.scaleFactor\n  self.mouseOwner.attrs[\"transform\"]=\"translate({},{})\".format(dx,dy)\n  if isinstance(self.mouseOwner,[EllipseObject,RectangleObject]):\n   self.mouseOwner.attrs[\"transform\"]+=self.mouseOwner.rotatestring\n   \n def endDrag(self,event):\n  self.mouseOwner.attrs[\"transform\"]=\"\"\n  currentcoords=self.getSVGcoords(event)\n  offset=currentcoords -self.StartPoint\n  self.translateObject(self.mouseOwner,offset)\n  if self.snap:\n   if self.rotateSnap:self.doRotateSnap(self.mouseOwner)\n   else :self.doSnap(self.mouseOwner)\n  self.mouseOwner=None\n  \n def getSelectedObject(self,objectid,getGroup=True ):\n  try :\n   svgobj=self.objectDict[objectid]\n  except KeyError:\n   return\n  try :\n   svgobj=svgobj.reference\n  except AttributeError:\n   pass\n  if getGroup:\n   while getattr(svgobj,\"Group\",None ):\n    svgobj=svgobj.Group\n  return svgobj\n  \n def doSnap(self,svgobject):\n  if not hasattr(svgobject,\"pointList\"):return\n  bbox=svgobject.getBBox()\n  L,R,T,B=bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height\n  bestdx=bestdy=None\n  for objid in self.objectDict:\n   if objid ==svgobject.id:continue\n   obj=self.objectDict[objid]\n   if not hasattr(obj,\"pointList\"):continue\n   bbox=obj.getBBox()\n   L1,R1,T1,B1=bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height\n   if L1 -R >self.snap or R1 -L <-self.snap or T1 -B >self.snap or B1 -T <-self.snap:continue\n   for point1 in obj.pointList:\n    for point2 in svgobject.pointList:\n     (dx,dy)=point1 -point2\n     if abs(dx)<self.snap and abs(dy)<self.snap:\n      if not bestdx or hypot(dx,dy)<hypot(bestdx,bestdy):\n       (bestdx,bestdy)=(dx,dy)\n  if bestdx or bestdy:\n   self.translateObject(svgobject,Point((bestdx,bestdy)))\n   \nclass Point(object):\n ''\n def __init__(self,coords):\n  self.coords=list(coords.coords)if isinstance(coords,Point)else list(coords)\n  \n def __str__(self):\n  return str(tuple(self.coords))\n  \n def __eq__(self,other):\n  return (self.coords ==other.coords)\n  \n def __add__(self,other):\n  if isinstance(other,Point):\n   return Point([xi+yi for (xi,yi)in zip(self.coords,other.coords)])\n  elif isinstance(other,(list,tuple)):\n   return Point([xi+yi for (xi,yi)in zip(self.coords,other)])\n  elif other is None :\n   return None\n  else :\n   return NotImplemented\n   \n def __radd__(self,other):\n  return self+other\n  \n def __iadd__(self,other):\n  if isinstance(other,(list,tuple)):\n   for i in range(len(self.coords)):\n    self.coords[i]+=other[i]\n  else :\n   for i in range(len(self.coords)):\n    self.coords[i]+=other.coords[i]\n  return self\n  \n def __sub__(self,other):\n  return Point([xi -yi for (xi,yi)in zip(self.coords,other.coords)])\n  \n def __mul__(self,other):\n  if isinstance(other,(int,float)):\n   return Point([other *xi for xi in self.coords])\n  elif isinstance(other,(list,tuple)):\n   return Point([xi *yi for (xi,yi)in zip(self.coords,other)])\n  elif isinstance(other,Point):\n   return sum([xi *yi for (xi,yi)in zip(self.coords,other.coords)])\n  elif isinstance(other,Matrix):\n   return Point([self *col for col in other.cols])\n  else :\n   return NotImplemented\n   \n def __rmul__(self,other):\n  if isinstance(other,(int,float)):\n   return Point([other *xi for xi in self.coords])\n  elif isinstance(other,(list,tuple)):\n   return Point([xi *yi for (xi,yi)in zip(self.coords,other)])\n  elif isinstance(other,Point):\n   return sum([xi *yi for (xi,yi)in zip(self.coords,other.coords)])\n  else :\n   return NotImplemented\n   \n def __truediv__(self,other):\n  return Point([xi /other for xi in self.coords])\n  \n def __getitem__(self,i):\n  return self.coords[i]\n  \n def __len__(self):\n  return len(self.coords)\n  \n def length(self):\n  (x,y)=self.coords\n  return hypot(x,y)\n  \n def angle(self):\n  return atan2(self.coords[1],self.coords[0])\n  \n  \nclass Matrix(object):\n def __init__(self,rows):\n  self.rows=rows\n  self.cols=[Point([self.rows[i][j]for i in range(len(self.rows))])for j in range(len(self.rows[0]))]\n  \n def __str__(self):\n  return str(\"\\n\".join(str(row)for row in self.rows))\n  \n def __rmul__(self,other):\n  if isinstance(other,(list,tuple)):\n   return [Point([p *col for col in self.cols])for p in other]\n  else :\n   return Point([other *col for col in self.cols])\n   \nshapetypes={\"line\":LineObject,\"polygon\":PolygonObject,\"polyline\":PolylineObject,\n\"rectangle\":RectangleObject,\"ellipse\":EllipseObject,\"circle\":CircleObject,\n\"bezier\":BezierObject,\"closedbezier\":ClosedBezierObject,\"smoothbezier\":SmoothBezierObject,\"smoothclosedbezier\":SmoothClosedBezierObject}\n", ["browser", "browser.svg", "math", "time"]], "brySVG.fullcanvas": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nfrom brySVG.transformcanvas import *\n\nclass NonBezierMixin(object):\n ''\n def setPoint(self,i,point):\n  self.pointList[i]=point\n  self.update()\n  \n def setPoints(self,pointlist):\n  self.pointList=pointlist\n  self.update()\n  \n def movePoint(self,coords):\n  self.setPoint(-1,coords)\n  \nclass PolyshapeMixin(object):\n ''\n def appendPoint(self,point):\n  self.pointList.append(point)\n  self.update()\n  \n def insertPoint(self,index,point):\n  self.pointList.insert(index,point)\n  self.update()\n  self.updatehittarget()\n  \n def deletePoints(self,start,end):\n  del self.pointList[slice(start,end)]\n  self.update()\n  \nclass BezierMixin(object):\n ''\n def setPointset(self,i,pointset):\n  self.pointList[i]=pointset[1]\n  self.pointsetList[i]=pointset\n  self.update()\n  \n def setPointsets(self,pointsetlist):\n  self.pointList=[pointset[1]for pointset in pointsetlist]\n  self.pointsetList=pointsetlist\n  self.update()\n  self.updatehittarget()\n  \n def setPoint(self,i,point):\n  self.pointList[i]=point\n  self.pointsetList=self.getpointsetlist(self.pointList)\n  self.update()\n  \n def setPoints(self,pointlist):\n  self.pointList=pointlist\n  self.pointsetList=self.getpointsetlist(pointlist)\n  self.update()\n  \n def appendPoint(self,point):\n  self.pointList.append(point)\n  self.pointsetList=self.getpointsetlist(self.pointList)\n  self.update()\n  \n def deletePoints(self,start,end):\n  del self.pointList[slice(start,end)]\n  self.pointsetList=self.getpointsetlist(self.pointList)\n  self.update()\n  \n def insertPoint(self,index,point):\n  self.pointList.insert(index,point)\n  if isinstance(self,SmoothBezierMixin):\n   self.pointsetList=self.getpointsetlist(self.pointList)\n  else :\n   L=len(self.pointList)\n   cpoint1,cpoint2=SmoothBezierMixin.calculatecontrolpoints(self,self.pointList[index -1:index+2])\n   \n   self.pointsetList.insert(index,[cpoint1,point,cpoint2])\n   self.pointsetList[index -1][2]=cpoint1\n   self.pointsetList[(index+1)%L][0]=cpoint2\n  self.update()\n  self.updatehittarget()\n  \n def movePoint(self,point):\n  self.pointList[-1]=point\n  self.updatepointsetlist()\n  if len(self.pointList)==2:\n   self.update()\n  elif isinstance(self,(ClosedBezierObject,SmoothClosedBezierObject)):\n   ((x1,x2),(x3,x4),(x5,x6))=self.pointsetList[-2]\n   ((x7,x8),(x9,x10),(x11,x12))=self.pointsetList[-1]\n   ((x13,x14),(x15,x16),(x17,x18))=self.pointsetList[0]\n   self.plist=self.plist[:-16]+[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16]\n   self.plist[4:6]=[x17,x18]\n   self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n  else :\n   ((x1,x2),(x3,x4),(x5,x6))=self.pointsetList[-2]\n   ((x7,x8),(x9,x10),dummy)=self.pointsetList[-1]\n   self.plist=self.plist[:-10]+[x1,x2,x3,x4,x5,x6,x7,x8,x9,x10]\n   self.attrs[\"d\"]=\" \".join(str(x)for x in self.plist)\n   \nclass DrawCanvasMixin(object):\n def createObject(self,coords):\n  colour=\"none\"if self.tool in [\"polyline\",\"bezier\",\"smoothbezier\"]else self.fillColour\n  self.mouseOwner=shapetypes[self.tool](pointlist=[coords,coords],linecolour=self.penColour,linewidth=self.penWidth,fillcolour=colour)\n  self.addObject(self.mouseOwner)\n  self.mouseOwner.shapeType=self.tool\n  \n def drawPoint(self,event):\n  if self.tool ==\"select\":return\n  if self.mouseOwner:\n   if isinstance(self.mouseOwner,(PolyshapeMixin,BezierMixin)):\n    coords=self.getSVGcoords(event)\n    self.mouseOwner.appendPoint(coords)\n  else :\n   self.startx=self.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n   self.starty=self.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n   coords=self.getSVGcoords(event)\n   self.createObject(coords)\n   \n def endDraw(self,event):\n  if not self.mouseOwner:return\n  svgobj=self.mouseOwner\n  if isinstance(svgobj,(PolyshapeMixin,BezierMixin)):\n   if event.type ==\"dblclick\":svgobj.deletePoints(-2,None )\n   elif self.mouseDetected:svgobj.deletePoints(-1,None )\n   elif svgobj.pointList[0]==svgobj.pointList[1]:svgobj.deletePoints(None ,1)\n  self.mouseOwner=None\n  self.mouseMode=MouseMode.EDIT\n  return svgobj\n  \n def createEditHitTargets(self):\n  objlist=list(self.objectDict.values())\n  for obj in objlist:\n   if obj.fixed:continue\n   if hasattr(obj,\"hitTarget\"):continue\n   if hasattr(obj,\"reference\"):continue\n   if isinstance(obj,(PolyshapeMixin,BezierMixin)):\n    newobj=HitTarget(obj,self)\n   else :\n    if obj.style.fill !=\"none\":continue\n    newobj=obj.cloneObject()\n    newobj.reference=obj\n    newobj.style.strokeWidth=10 *self.scaleFactor if self.mouseDetected else 25 *self.scaleFactor\n    newobj.style.opacity=0\n   obj.hitTarget=newobj\n   self.hittargets.append(newobj)\n   self.addObject(newobj)\n   \n def prepareEdit(self,event):\n  if self.selectedObject:self.deselectObject()\n  svgobject=self.getSelectedObject(event.target.id,getGroup=False )\n  if not svgobject or svgobject.fixed:return\n  self.selectedObject=svgobject\n  self.createHandles(svgobject)\n  \n def createHandles(self,svgobject):\n  if isinstance(svgobject,BezierMixin):\n   handles=[]\n   for i,(point0,point1,point2)in enumerate(svgobject.pointsetList):\n    handle=Handle(svgobject,i,point1,\"red\",self)\n    handle.controlHandles=[]\n    ch0=None if point0 is None else ControlHandle(svgobject,i,0,point0,\"green\",self)\n    ch2=None if point2 is None else ControlHandle(svgobject,i,2,point2,\"green\",self)\n    if ch0:\n     ch0.linkedHandle=ch2 if isinstance(svgobject,SmoothBezierMixin)else None\n     handle.controlHandles.append(ch0)\n    if ch2:\n     ch2.linkedHandle=ch0 if isinstance(svgobject,SmoothBezierMixin)else None\n     handle.controlHandles.append(ch2)\n    handles.append(handle)\n   self.handles=GroupObject(handles)\n   self <=self.handles\n   self.controlhandles=GroupObject([ch for handle in handles for ch in handle.controlHandles])\n   self <=self.controlhandles\n  else :\n   self.handles=GroupObject([Handle(svgobject,i,coords,\"red\",self)for i,coords in enumerate(svgobject.pointList)])\n   self <=self.handles\n   \n def movePoint(self,event):\n  x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  dx,dy=x -self.currentx,y -self.currenty\n  if \"touch\"in event.type and abs(dx)<5 and abs(dy)<5:return\n  self.currentx,self.currenty=x,y\n  if self.mouseMode ==MouseMode.DRAW:\n   coords=self.getSVGcoords(event)\n   self.mouseOwner.movePoint(coords)\n  else :\n   if self.mouseMode ==MouseMode.TRANSFORM:dx,dy=x -self.startx,y -self.starty\n   dx,dy=dx *self.scaleFactor,dy *self.scaleFactor\n   self.mouseOwner.movePoint((dx,dy))\n   \n def insertPoint(self,event):\n  if not self.selectedObject:return None ,None\n  try :\n   index=self.objectDict[event.target.id].segmentindex\n  except AttributeError:\n   return None ,None\n  self.deleteObject(self.handles)\n  self.deleteObject(self.controlhandles)\n  clickpoint=self.getSVGcoords(event)\n  svgobject=self.selectedObject\n  svgobject.insertPoint(index,clickpoint)\n  svgobject.updatehittarget()\n  self.createHandles(svgobject)\n  return index,clickpoint\n  \n def endEdit(self,event):\n  if self.selectedObject:\n   self.selectedObject.updatehittarget()\n   if self.handles:self <=self.handles\n   if self.controlhandles:self <=self.controlhandles\n  self.mouseOwner=None\n  \n def deselectObject(self):\n  if not self.selectedObject:return\n  self.deleteHandles()\n  self.mouseOwner=self.selectedObject=self.selectedhandle=None\n  \n def deleteHandles(self):\n  self.deleteObject(self.handles)\n  self.handles=None\n  if isinstance(self.selectedObject,BezierMixin):\n   self.deleteObject(self.controlhandles)\n   self.controlhandles=None\n   \nclass HitTargetSegment(LineObject):\n def __init__(self,pointlist,width,reference,index):\n  LineObject.__init__(self,pointlist,linewidth=width)\n  self.reference=reference\n  self.segmentindex=index\n  self.style.opacity=0\n  \nclass BezierHitTargetSegment(BezierObject):\n def __init__(self,pointsetlist,width,reference,index):\n  BezierObject.__init__(self,pointsetlist,linewidth=width)\n  self.reference=reference\n  self.segmentindex=index\n  self.style.opacity=0\n  \nclass HitTarget(GroupObject):\n def __init__(self,reference,canvas):\n  GroupObject.__init__(self)\n  self.reference=reference\n  self.canvas=canvas\n  self.update()\n  \n def update(self):\n  self.deleteAll()\n  width=10 *self.canvas.scaleFactor if self.canvas.mouseDetected else 25 *self.canvas.scaleFactor\n  if isinstance(self.reference,PolyshapeMixin):\n   pointlist=self.reference.pointList[:]\n   if isinstance(self.reference,PolygonObject):pointlist.append(pointlist[0])\n   for i in range(len(pointlist)-1):\n    segment=HitTargetSegment(pointlist[i:i+2],width,self.reference,i+1)\n    self.addObject(segment)\n  else :\n   pointsetlist=self.reference.pointsetList[:]\n   if isinstance(self.reference,(ClosedBezierObject,SmoothClosedBezierObject)):pointsetlist.append(pointsetlist[0])\n   for i in range(len(pointsetlist)-1):\n    ps0=[None ]+pointsetlist[i][1:]\n    ps1=pointsetlist[i+1][:-1]+[None ]\n    segment=BezierHitTargetSegment([ps0,ps1],width,self.reference,i+1)\n    self.addObject(segment)\n  self.canvas.deleteObject(self)\n  self.canvas.addObject(self)\n  \nclass Handle(PointObject):\n def __init__(self,owner,index,coords,colour,canvas):\n  pointsize=7 if canvas.mouseDetected else 15\n  opacity=0.4\n  strokewidth=3\n  PointObject.__init__(self,coords,colour,pointsize,canvas)\n  self.style.strokeWidth=strokewidth\n  self.style.fillOpacity=opacity\n  self.owner=owner\n  self.index=index\n  self.canvas=canvas\n  self.bind(\"mousedown\",self.select)\n  self.bind(\"touchstart\",self.select)\n  \n def select(self,event):\n  event.stopPropagation()\n  self.canvas.startx=self.canvas.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  self.canvas.starty=self.canvas.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  self.canvas.mouseOwner=self\n  if isinstance(self.owner,BezierMixin):\n   if self.canvas.selectedhandle:\n    for ch in self.canvas.selectedhandle.controlHandles:ch.style.visibility=\"hidden\"\n   for ch in self.controlHandles:ch.style.visibility=\"visible\"\n  self.canvas.selectedhandle=self\n  \n def movePoint(self,offset):\n  self.XY +=offset\n  if isinstance(self.owner,BezierMixin):\n   pointset=[None ,self.XY,None ]\n   for ch in self.controlHandles:\n    ch.XY +=offset\n    pointset[ch.subindex]=ch.XY\n   self.owner.setPointset(self.index,pointset)\n  else :\n   self.owner.setPoint(self.index,self.XY)\n   \nclass ControlHandle(PointObject):\n def __init__(self,owner,index,subindex,coords,colour,canvas):\n  pointsize=7 if canvas.mouseDetected else 15\n  opacity=0.4\n  strokewidth=3\n  PointObject.__init__(self,coords,colour,pointsize,canvas)\n  self.style.fillOpacity=opacity\n  self.style.strokeWidth=strokewidth\n  self.style.visibility=\"hidden\"\n  self.owner=owner\n  self.index=index\n  self.subindex=subindex\n  self.canvas=canvas\n  self.bind(\"mousedown\",self.select)\n  self.bind(\"touchstart\",self.select)\n  \n def select(self,event):\n  event.stopPropagation()\n  self.canvas.startx=self.canvas.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  self.canvas.starty=self.canvas.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  self.canvas.mouseOwner=self\n  \n def movePoint(self,offset):\n  self.XY +=offset\n  pointset=self.owner.pointsetList[self.index]\n  pointset[self.subindex]=self.XY\n  if self.linkedHandle:\n   point=pointset[1]\n   thisoffset=self.XY -point\n   otheroffset=self.linkedHandle.XY -point\n   newoffset=thisoffset *(otheroffset.length()/thisoffset.length())\n   newothercoords=point -newoffset\n   pointset[self.linkedHandle.subindex]=newothercoords\n   self.linkedHandle.XY=newothercoords\n  self.owner.setPointset(self.index,pointset)\n  \nclass LineObject(LineObject,NonBezierMixin):\n pass\n \nclass PolylineObject(PolylineObject,NonBezierMixin,PolyshapeMixin):\n pass\n \nclass PolygonObject(PolygonObject,NonBezierMixin,PolyshapeMixin):\n pass\n \nclass RectangleObject(RectangleObject,NonBezierMixin):\n pass\n \nclass EllipseObject(EllipseObject,NonBezierMixin):\n pass\n \nclass CircleObject(CircleObject,NonBezierMixin):\n pass\n \nclass BezierObject(BezierObject,BezierMixin):\n pass\n \nclass ClosedBezierObject(ClosedBezierObject,BezierMixin):\n pass\n \nclass SmoothBezierObject(SmoothBezierObject,BezierMixin):\n pass\n \nclass SmoothClosedBezierObject(SmoothClosedBezierObject,BezierMixin):\n pass\n \nclass RegularPolygon(RegularPolygon,NonBezierMixin):\n pass\n \nclass CanvasObject(CanvasObject,DrawCanvasMixin):\n pass\n \nshapetypes={\"line\":LineObject,\"polygon\":PolygonObject,\"polyline\":PolylineObject,\n\"rectangle\":RectangleObject,\"ellipse\":EllipseObject,\"circle\":CircleObject,\n\"bezier\":BezierObject,\"closedbezier\":ClosedBezierObject,\"smoothbezier\":SmoothBezierObject,\"smoothclosedbezier\":SmoothClosedBezierObject}\n\n", ["brySVG.transformcanvas"]], "brySVG": [".py", "", [], 1], "brySVG.transformcanvas": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nfrom brySVG.dragcanvas import *\n\nclass TransformMixin(object):\n ''\n\n \n \n def cloneObject(self):\n  ''\n\n  \n  newobject=self.__class__()\n  if isinstance(newobject,GroupObject):\n   newobject.ObjectList=[]\n   for obj in self.ObjectList:\n    newobj=obj.cloneObject()\n    newobject.addObject(newobj)\n  elif isinstance(self,PointObject):\n   newobject.XY=self.XY\n  else :\n   newobject.pointList=self.pointList[:]\n   if isinstance(self,BezierMixin):newobject.pointsetList=self.pointsetList[:]\n  if hasattr(self,\"angle\"):newobject.angle=self.angle\n  for (key,value)in self.attrs.items():\n   newobject.attrs[key]=value\n  return newobject\n  \n def transformedpointlist(self,matrix):\n  ''\n  pt=svgbase.createSVGPoint()\n  newpointlist=[]\n  for point in self.pointList:\n   (pt.x,pt.y)=point\n   pt=pt.matrixTransform(matrix)\n   newpointlist.append(Point((pt.x,pt.y)))\n  return newpointlist\n  \n def transformedpoint(self,matrix):\n  ''\n  pt=svgbase.createSVGPoint()\n  (pt.x,pt.y)=self.XY\n  pt=pt.matrixTransform(matrix)\n  return Point((pt.x,pt.y))\n  \n def transformedpointsetlist(self,matrix):\n  ''\n  pt=svgbase.createSVGPoint()\n  newpointsetlist=[]\n  for pointset in self.pointsetList:\n   newpointset=[]\n   for point in pointset:\n    if point is None :\n     newpointset.append(None )\n    else :\n     (pt.x,pt.y)=point\n     pt=pt.matrixTransform(matrix)\n     newpointset.append(Point((pt.x,pt.y)))\n   newpointsetlist.append(newpointset)\n  return newpointsetlist\n  \n def matrixTransform(self,matrix):\n  ''\n  if isinstance(self,PointObject):\n   self.XY=self.transformedpoint(matrix)\n  else :\n   self.pointList=self.transformedpointlist(matrix)\n   if isinstance(self,BezierMixin):self.pointsetList=self.transformedpointsetlist(matrix)\n   hittarget=getattr(self,\"hitTarget\",None )\n   if hittarget:\n    hittarget.pointList=self.pointList\n    if isinstance(self,BezierMixin):hittarget.pointsetList=self.pointsetList\n    hittarget.update()\n  self.update()\n  \n def translate(self,vector):\n  ''\n  if isinstance(self,GroupObject):\n   for obj in self.ObjectList:\n    obj.translate(vector)\n  else :\n   t=svgbase.createSVGTransform()\n   t.setTranslate(*vector)\n   self.matrixTransform(t.matrix)\n   \n def rotate(self,angle,centre=None ):\n  ''\n  \n  if not centre:\n   bbox=self.getBBox()\n   centre=(bbox.x+bbox.width /2,bbox.y+bbox.height /2)\n  if isinstance(self,GroupObject):\n   for obj in self.ObjectList:\n    obj.rotate(angle,centre)\n  else :\n   if isinstance(self,(EllipseObject,RectangleObject)):\n    self.angle +=angle\n   t=svgbase.createSVGTransform()\n   t.setRotate(angle,*centre)\n   self.matrixTransform(t.matrix)\n   \n def rotateByVectors(self,vec1,vec2,centre=(0,0)):\n  ''\n  \n  if isinstance(self,GroupObject):\n   for obj in self.ObjectList:\n    obj.rotateByVectors(vec1,vec2,centre)\n  else :\n   (cx,cy)=centre\n   (x1,y1)=vec1\n   (x2,y2)=vec2\n   (x3,y3)=(x1 *x2+y1 *y2,x1 *y2 -x2 *y1)\n   angle=atan2(y3,x3)*180 /pi\n   if isinstance(self,(EllipseObject,RectangleObject)):\n    self.angle +=angle\n   matrix=svgbase.createSVGMatrix()\n   matrix=matrix.translate(cx,cy)\n   matrix=matrix.rotateFromVector(x3,y3)\n   matrix=matrix.translate(-cx,-cy)\n   self.matrixTransform(matrix)\n   \n def xstretch(self,xscale,cx=0):\n  ''\n  \n  if isinstance(self,GroupObject):\n   for obj in self.ObjectList:\n    obj.xstretch(xscale,cx)\n  else :\n   angle=0\n   if isinstance(self,[EllipseObject,RectangleObject])and self.angle !=0:\n    angle=self.angle\n    self.rotate(-angle)\n   matrix=svgbase.createSVGMatrix()\n   matrix=matrix.translate(cx,0)\n   matrix.a=xscale\n   matrix=matrix.translate(-cx,0)\n   self.matrixTransform(matrix)\n   if angle !=0:self.rotate(angle)\n   \n def ystretch(self,yscale,cy=0):\n  ''\n  \n  if isinstance(self,GroupObject):\n   for obj in self.ObjectList:\n    obj.ystretch(yscale,cy)\n  else :\n   angle=0\n   if isinstance(self,[EllipseObject,RectangleObject])and self.angle !=0:\n    angle=self.angle\n    self.rotate(-angle)\n   matrix=svgbase.createSVGMatrix()\n   matrix=matrix.translate(0,cy)\n   matrix.d=yscale\n   matrix=matrix.translate(0,-cy)\n   self.matrixTransform(matrix)\n   if angle !=0:self.rotate(angle)\n   \n def enlarge(self,scalefactor,centre):\n  ''\n  \n  if isinstance(self,GroupObject):\n   for obj in self.ObjectList:\n    obj.enlarge(scalefactor,centre)\n  else :\n   (cx,cy)=centre\n   matrix=svgbase.createSVGMatrix()\n   matrix=matrix.translate(cx,cy)\n   matrix=matrix.scale(scalefactor)\n   matrix=matrix.translate(-cx,-cy)\n   self.matrixTransform(matrix)\n   \nclass TransformCanvasMixin(object):\n def prepareTransform(self,event):\n  self.selectedObject=self.getSelectedObject(event.target.id)\n  if self.selectedObject and not self.selectedObject.fixed:\n   self <=self.selectedObject\n   self.showTransformHandles(self.selectedObject)\n   if TransformType.TRANSLATE in self.transformTypes:self.transformHandles[TransformType.TRANSLATE].select(event)\n  else :\n   self.hideTransformHandles()\n   \n def endTransform(self,event):\n  if not isinstance(self.mouseOwner,TransformHandle):return\n  currentcoords=self.getSVGcoords(event)\n  offset=currentcoords -self.StartPoint\n  if offset.coords !=[0,0]:\n   centre=(cx,cy)=self.selectedObject.Centre\n   vec1=(x1,y1)=self.StartPoint -centre\n   vec2=(x2,y2)=currentcoords -centre\n   transformtype=self.mouseOwner.transformType\n   \n   self.selectedObject.attrs[\"transform\"]=\"\"\n   if transformtype ==TransformType.TRANSLATE:\n    self.selectedObject.translate(offset)\n   elif transformtype ==TransformType.ROTATE:\n    self.selectedObject.rotateByVectors(vec1,vec2,(cx,cy))\n   elif transformtype ==TransformType.XSTRETCH:\n    self.selectedObject.xstretch(x2 /x1,cx)\n   elif transformtype ==TransformType.YSTRETCH:\n    self.selectedObject.ystretch(y2 /y1,cy)\n   elif transformtype ==TransformType.ENLARGE:\n    self.selectedObject.enlarge(hypot(x2,y2)/hypot(x1,y1),(cx,cy))\n    \n   if self.snap:\n    if self.rotateSnap:self.doRotateSnap(self.selectedObject)\n    else :self.doSnap(self.selectedObject)\n    \n  if self.transformorigin:\n   self.deleteObject(self.transformorigin)\n   self.transformorigin=None\n  self.showTransformHandles(self.selectedObject)\n  self.mouseOwner=None\n  \n def showTransformHandles(self,svgobj):\n  tempgroup=GroupObject([svgobj.cloneNode(True )])\n  self <=tempgroup\n  bbox=tempgroup.getBBox()\n  x1,y1,x2,y2=bbox.x,bbox.y,bbox.x+bbox.width,bbox.y+bbox.height\n  self.deleteObject(tempgroup)\n  svgobj.Centre=Point(((x1+x2)/2,(y1+y2)/2))\n  \n  self.transformBBox.pointList=[Point((x1,y1)),Point((x2,y2))]\n  self.transformBBox.update()\n  self <=self.transformBBox\n  self.transformBBox.style.visibility=\"visible\"\n  if not self.transformHandles:self.transformHandles=[self.transformBBox]+[TransformHandle(None ,i,(0,0),self)for i in range(1,6)]\n  for i,coords in enumerate([((x1+x2)/2,(y1+y2)/2),(x1,y1),(x2,(y1+y2)/2),((x1+x2)/2,y2),(x2,y2)]):\n   self.transformHandles[i+1].XY=coords\n   self.transformHandles[i+1].owner=svgobj\n  for ttype in self.transformTypes:\n   thandle=self.transformHandles[ttype]\n   self <=thandle\n   if ttype !=TransformType.TRANSLATE:thandle.style.visibility=\"visible\"\n  return [(x1,y1),(x2,y2)]\n  \n def hideTransformHandles(self):\n  for obj in self.transformHandles:obj.style.visibility=\"hidden\"\n  \n def showTransformOrigin(self,transformtype):\n  [(x1,y1),(x2,y2)]=self.transformBBox.pointList\n  (cx,cy)=((x1+x2)/2,(y1+y2)/2)\n  if transformtype in [TransformType.NONE,TransformType.TRANSLATE]:return\n  if transformtype in [TransformType.ROTATE,TransformType.ENLARGE]:\n   self.transformorigin=PointObject((cx,cy),colour=\"blue\",pointsize=3,canvas=self)\n  elif transformtype ==TransformType.XSTRETCH:\n   self.transformorigin=LineObject([(cx,y1),(cx,y2)],linecolour=\"blue\",linewidth=2)\n  elif transformtype ==TransformType.YSTRETCH:\n   self.transformorigin=LineObject([(x1,cy),(x2,cy)],linecolour=\"blue\",linewidth=2)\n  self <=self.transformorigin\n  \n def movePoint(self,event):\n  x=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  y=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  dx,dy=x -self.currentx,y -self.currenty\n  if \"touch\"in event.type and abs(dx)<5 and abs(dy)<5:return\n  self.currentx,self.currenty=x,y\n  if self.mouseMode ==MouseMode.DRAW:\n   coords=self.getSVGcoords(event)\n   self.mouseOwner.movePoint(coords)\n  else :\n   if self.mouseMode ==MouseMode.TRANSFORM:dx,dy=x -self.startx,y -self.starty\n   dx,dy=dx *self.scaleFactor,dy *self.scaleFactor\n   self.mouseOwner.movePoint((dx,dy))\n   \n def doRotateSnap(self,svgobject):\n  if not hasattr(svgobject,\"pointList\"):return\n  bbox=svgobject.getBBox()\n  L,R,T,B=bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height\n  bestdx=bestdy=None\n  for objid in self.objectDict:\n   if objid ==svgobject.id:continue\n   obj=self.objectDict[objid]\n   if not hasattr(obj,\"pointList\"):continue\n   bbox=obj.getBBox()\n   L1,R1,T1,B1=bbox.x,bbox.x+bbox.width,bbox.y,bbox.y+bbox.height\n   if L1 -R >self.snap or R1 -L <-self.snap or T1 -B >self.snap or B1 -T <-self.snap:continue\n   for point1 in obj.pointList:\n    for point2 in svgobject.pointList:\n     (dx,dy)=point1 -point2\n     if abs(dx)<self.snap and abs(dy)<self.snap:\n      pl1=self.objectDict[objid].pointList\n      L=len(pl1)\n      i=pl1.index(point1)\n      vec1a=pl1[(i+1)%L]-point1\n      vec1b=pl1[(i -1)%L]-point1\n      angles1=[vec1a.angle(),vec1b.angle()]\n      pl2=svgobject.pointList\n      L=len(pl2)\n      j=pl2.index(point2)\n      vec2a=pl2[(j+1)%L]-point2\n      vec2b=pl2[(j -1)%L]-point2\n      angles2=[vec2a.angle(),vec2b.angle()]\n      for a1 in angles1:\n       for a2 in angles2:\n        diff=a1 -a2\n        absdiff=abs(diff)\n        testdiff=absdiff if absdiff <pi else 2 *pi -absdiff\n        \n        if testdiff <self.rotateSnap *pi /180:\n         svgobject.rotate(diff *180 /pi)\n         (dx,dy)=self.objectDict[objid].pointList[i]-svgobject.pointList[j]\n         svgobject.translate((dx,dy))\n         return\n      if not bestdx or hypot(dx,dy)<hypot(bestdx,bestdy):(bestdx,bestdy)=(dx,dy)\n  if bestdx:\n   svgobject.translate((bestdx,bestdy))\n   \nclass TransformHandle(PointObject):\n def __init__(self,owner,transformtype,coords,canvas):\n  pointsize=7 if canvas.mouseDetected else 15\n  opacity=1 if canvas.mouseDetected else 0.2\n  strokewidth=1 if canvas.mouseDetected else 3\n  PointObject.__init__(self,coords,\"red\",pointsize,canvas)\n  self.style.fillOpacity=opacity\n  self.style.strokeWidth=strokewidth\n  self.owner=owner\n  self.canvas=canvas\n  self.transformType=transformtype\n  self.bind(\"mousedown\",self.select)\n  self.bind(\"touchstart\",self.select)\n  \n def select(self,event):\n  event.stopPropagation()\n  self.canvas.mouseOwner=self\n  self.startx,self.starty=self.canvas.StartPoint=self.canvas.getSVGcoords(event)\n  self.canvas.startx=self.canvas.currentx=event.targetTouches[0].clientX if \"touch\"in event.type else event.clientX\n  self.canvas.starty=self.canvas.currenty=event.targetTouches[0].clientY if \"touch\"in event.type else event.clientY\n  self.canvas.hideTransformHandles()\n  if self.transformType !=TransformType.TRANSLATE:self.style.visibility=\"visible\"\n  self.canvas.showTransformOrigin(self.transformType)\n  \n def movePoint(self,offset):\n  (dx,dy)=offset\n  if (dx,dy)==(0,0):return\n  (x,y)=self.startx+dx,self.starty+dy\n  self.XY=(x,y)\n  if self.transformType ==TransformType.TRANSLATE:\n   transformstring=\"translate({},{})\".format(dx,dy)\n   if isinstance(self.owner,[EllipseObject,RectangleObject])and self.owner.angle !=0:\n    self.owner.attrs[\"transform\"]=transformstring+self.owner.rotatestring\n   else :\n    self.owner.attrs[\"transform\"]=transformstring\n   return\n   \n  (cx,cy)=self.owner.Centre\n  (x1,y1)=self.startx -cx,self.starty -cy\n  (x2,y2)=x -cx,y -cy\n  \n  if self.transformType ==TransformType.ROTATE:\n   (x3,y3)=(x1 *x2+y1 *y2,x1 *y2 -x2 *y1)\n   angle=atan2(y3,x3)*180 /pi\n   transformstring=\"rotate({},{},{})\".format(angle,cx,cy)\n  elif self.transformType ==TransformType.XSTRETCH:\n   xfactor=x2 /x1\n   yfactor=xfactor if isinstance(self.owner,CircleObject)else 1\n   transformstring=\"translate({},{}) scale({},{}) translate({},{})\".format(cx,cy,xfactor,yfactor,-cx,-cy)\n  elif self.transformType ==TransformType.YSTRETCH:\n   yfactor=y2 /y1\n   xfactor=yfactor if isinstance(self.owner,CircleObject)else 1\n   transformstring=\"translate({},{}) scale({},{}) translate({},{})\".format(cx,cy,xfactor,yfactor,-cx,-cy)\n  elif self.transformType ==TransformType.ENLARGE:\n   transformstring=\"translate({},{}) scale({}) translate({},{})\".format(cx,cy,hypot(x2,y2)/hypot(x1,y1),-cx,-cy)\n   \n  if isinstance(self.owner,[EllipseObject,RectangleObject])and self.owner.angle !=0:\n   self.owner.attrs[\"transform\"]=self.owner.rotatestring+transformstring\n  else :\n   self.owner.attrs[\"transform\"]=transformstring\n   \nclass LineObject(LineObject,TransformMixin):\n pass\n \nclass PolylineObject(PolylineObject,TransformMixin):\n pass\n \nclass PolygonObject(PolygonObject,TransformMixin):\n pass\n \nclass RectangleObject(RectangleObject,TransformMixin):\n pass\n \nclass EllipseObject(EllipseObject,TransformMixin):\n pass\n \nclass CircleObject(CircleObject,TransformMixin):\n pass\n \nclass BezierObject(BezierObject,TransformMixin):\n pass\n \nclass ClosedBezierObject(ClosedBezierObject,TransformMixin):\n pass\n \nclass SmoothBezierObject(SmoothBezierObject,TransformMixin):\n pass\n \nclass SmoothClosedBezierObject(SmoothClosedBezierObject,TransformMixin):\n pass\n \nclass PointObject(PointObject,TransformMixin):\n pass\n \nclass RegularPolygon(RegularPolygon,TransformMixin):\n pass\n \nclass GroupObject(GroupObject,TransformMixin):\n pass\n \nclass CanvasObject(CanvasObject,TransformCanvasMixin):\n pass\n", ["brySVG.dragcanvas"]], "brySVG.polygontesting": [".py", "#!/usr/bin/python\n\n\n\n\n\n\n\n\n\n\n\nclass Enum(list):\n def __init__(self,name,string):\n  values=string.split()\n  for i,value in enumerate(values):\n   setattr(self,value,i)\n   self.append(i)\n   \nPosition=Enum('Position','CONTAINS INSIDE OVERLAPS EQUAL DISJOINT')\n\ndef containspoint(poly,point,dp=1):\n ''\n\n \n poly=getattr(poly,\"pointList\",poly)\n poly=[(round(x,dp),round(y,dp))for (x,y)in poly]\n point=getattr(point,\"XY\",point)\n (x,y)=(round(point[0],dp),round(point[1],dp))\n if (x,y)in poly:return \"vertex\"\n length=len(poly)\n counter=0\n (x1,y1)=poly[0]\n for i in range(1,length+1):\n  (x2,y2)=poly[i %length]\n  if x1 ==x2 ==x and min(y1,y2)<=y <=max(y1,y2):return \"edge\"\n  if y1 ==y2:\n   if y ==y1 and min(x1,x2)<=x <=max(x1,x2):return \"edge\"\n  elif min(y1,y2)<y <=max(y1,y2)and x <max(x1,x2):\n   xcheck=x1+(y -y1)*(x2 -x1)/(y2 -y1)\n   if x ==xcheck:return \"edge\"\n   elif x <xcheck:\n    counter +=1\n  (x1,y1)=(x2,y2)\n return \"interior\"if counter %2 ==1 else False\n \ndef polygonobjectarea(poly):\n ''\n return polygonarea(poly.pointList)\n \ndef polygonarea(poly):\n ''\n area=0\n (x0,y0)=poly[-1]\n for (x1,y1)in poly:\n  area +=x1 *y0 -x0 *y1\n  (x0,y0)=(x1,y1)\n return abs(area /2)\n \ndef equalpolygonobjects(poly1,poly2):\n ''\n return equalpolygons(poly1.pointList,poly2.Pointlist)\n \ndef equalpolygons(poly1,poly2):\n ''\n \n start1=poly1.index(min(poly1))\n poly1=poly1[start1+1:]+poly1[:start1]\n start2=poly2.index(min(poly2))\n poly2=poly2[start2+1:]+poly2[:start2]\n return poly1 ==poly2 or poly1 ==poly2[::-1]\n \ndef polygonobjectboundingbox(poly):\n ''\n return polygonboundingbox(poly.pointList)\n \ndef polygonboundingbox(poly):\n ''\n xcoords=[x for (x,y)in poly]\n left=min(xcoords)\n right=max(xcoords)\n ycoords=[y for (x,y)in poly]\n top=min(ycoords)\n bottom=max(ycoords)\n return (left,top),(right,bottom)\n \ndef relativeposition(poly1,poly2,dp=1):\n ''\n\n \n ABOVE,BELOW,CONTAINS,ABOVEORCONTAINS,BELOWORCONTAINS=0,1,2,3,4\n ENDING,ONGOING,STARTING=0,1,2\n START,END=0,1\n \n def makeregion(ID,bounds,status):\n  return {\"ID\":ID,\"bounds\":bounds,\"status\":status,\"position\":{}}\n  \n def compareboundingboxes(poly1,poly2):\n  ((left1,top1),(right1,bottom1))=polygonboundingbox(poly1)\n  ((left2,top2),(right2,bottom2))=polygonboundingbox(poly2)\n  if right1 <=left2 or right2 <=left1 or bottom1 <=top2 or bottom2 <=top1:return Position.DISJOINT\n  if left1 <left2:\n   if right1 <right2:return Position.OVERLAPS\n   else :xresult=Position.CONTAINS\n  elif left1 ==left2:\n   xresult=Position.INSIDE if right1 <right2 else Position.EQUAL if right1 ==right2 else Position.CONTAINS\n  else :\n   if right1 >right2:return Position.OVERLAPS\n   else :xresult=Position.INSIDE\n   \n  if top1 <top2:\n   if bottom1 <bottom2:return Position.OVERLAPS\n   else :return Position.OVERLAPS if xresult ==Position.INSIDE else Position.CONTAINS\n  elif top1 ==top2:\n   if bottom1 <bottom2:return Position.OVERLAPS if xresult ==Position.CONTAINS else Position.INSIDE\n   elif bottom1 ==bottom2:return xresult\n   else :return Position.OVERLAPS if xresult ==Position.INSIDE else Position.CONTAINS\n  else :\n   if bottom1 >bottom2:return Position.OVERLAPS\n   else :return Position.OVERLAPS if xresult ==Position.CONTAINS else Position.INSIDE\n   \n def getintervals(poly,x):\n  ''\n  \n  yvalues=[]\n  L=len(poly)\n  i=0\n  while i <L:\n   (x1,y1)=poly[i]\n   (x2,y2)=poly[(i+1)%L]\n   if (x1 <x and x2 >x)or (x1 >x and x2 <x):\n    yvalues.append((round(y1+(x -x1)*(y2 -y1)/(x2 -x1),dp),\"N\"))\n   elif x1 ==x and x2 ==x:\n    (x0,y0)=poly[(i -1)%L]\n    (x3,y3)=poly[(i+2)%L]\n    t1=\"L\"if x0 <x else \"R\"\n    t2=\"L\"if x3 <x else \"R\"\n    if t1 ==t2:\n     yvalues.extend([(round(y1,dp),t1),(round(y2,dp),t2)])\n    else :\n     yvalues.append(([round(y1,dp),round(y2,dp)],t1+t2))\n    i +=1\n    if i ==L:del yvalues[0]\n   elif x1 ==x:\n    vertex=round(y1,dp)\n    (x0,y0)=poly[(i -1)%L]\n    t=\"L\"if (x0 <x and x2 <x)else \"R\"if (x0 >x and x2 >x)else \"N\"\n    yvalues.append((vertex,t))\n    if t in [\"L\",\"R\"]:\n     yvalues.append((vertex,t))\n   i +=1\n   \n  yvalues.sort(key=lambda x:[x[0]]if not isinstance(x[0],list)else x[0])\n  intervals=[]\n  for i in range(0,len(yvalues),2):\n   y0=yvalues[i]\n   y1=yvalues[i+1]\n   if isinstance(y0,list):\n    if not (i >0 and y0 ==intervals[-1]):intervals.append(y0)\n    if isinstance(y1,list):\n     if y1 !=y0:intervals.append(y1)\n    else :\n     intervals.append((y0[1],y1))\n   elif isinstance(y1,list):\n    intervals.extend([(y0,y1[0]),y1])\n   else :\n    intervals.append((y0,y1))\n  return intervals\n  \n def getregions(intervals,rlist,nextrlabel):\n \n  rlist=[region for region in rlist if region[\"status\"]!=ENDING]\n  rcount=len(rlist)\n  rindex=0\n  newrlist=[]\n  for (y1,t1),(y2,t2)in intervals:\n   startregion=False\n   oldy1=y1[0]if t1 ==\"LR\"else y1[1]if t1 ==\"RL\"else y1\n   newy1=y1[0]if t1 ==\"RL\"else y1[1]if t1 ==\"LR\"else y1\n   oldy2=y2[0]if t2 ==\"LR\"else y2[1]if t2 ==\"RL\"else y2\n   newy2=y2[0]if t2 ==\"RL\"else y2[1]if t2 ==\"LR\"else y2\n   if t1 ==\"R\"and t2 ==\"R\"and (rindex >=rcount or newy2 <rlist[rindex][\"bounds\"][START]):\n    startregion=True\n    rlist.append(makeregion(chr(nextrlabel),[newy1,newy2],STARTING))\n    nextrlabel +=1\n   elif t1 ==\"L\"and t2 ==\"L\":\n    print(rlist,rindex,rcount)\n    rlist[rindex][\"bounds\"]=[oldy1,oldy2]\n    rlist[rindex][\"status\"]=ENDING\n   elif t1 ==\"N\":\n    rlist[rindex][\"bounds\"][START]=oldy1\n    if rlist[rindex][\"status\"]==STARTING:rlist[rindex][\"status\"]=ONGOING\n   elif t1 in [\"RL\",\"LR\"]:\n    rlist[rindex][\"bounds\"][START]=oldy1\n    rlist[rindex][\"status\"]=ENDING\n    newrlist.append(makeregion(chr(nextrlabel),[newy1,None ],STARTING))\n    nextrlabel +=1\n   elif t1 ==\"R\":\n    newrlist.append(makeregion(chr(nextrlabel),[newy1,None ],STARTING))\n    nextrlabel +=1\n   elif t1 ==\"L\":\n    rlist[rindex][\"bounds\"][START]=oldy1\n    rlist[rindex][\"status\"]=ENDING\n   if t2 ==\"N\":\n    rlist[rindex][\"bounds\"][END]=oldy2\n    if rlist[rindex][\"status\"]==STARTING:rlist[rindex][\"status\"]=ONGOING\n    if newrlist:newrlist[-1][\"bounds\"][END]=newy2\n    \n   elif t2 in [\"RL\",\"LR\"]:\n    rlist[rindex][\"bounds\"][END]=oldy2\n    rlist[rindex][\"status\"]=ENDING\n    if newrlist:\n     newrlist[-1][\"bounds\"][END]=newy2\n    else :\n     newrlist.append(makeregion(chr(nextrlabel),[newy1,newy2],STARTING))\n     nextrlabel +=1\n   elif t2 ==\"R\"and not startregion:\n    rlist[rindex][\"status\"]=ENDING\n    if not newrlist:\n     newrlist.append(makeregion(chr(nextrlabel),[newy1,newy2],STARTING))\n     nextrlabel +=1\n    else :\n     newrlist[-1][\"bounds\"][END]=newy2\n   elif t2 ==\"L\"and t1 !=\"L\":\n    rlist[rindex][\"bounds\"][END]=oldy2\n    rlist[rindex][\"status\"]=ENDING\n    if not newrlist:\n     newrlist.append(makeregion(chr(nextrlabel),[newy1,None ],STARTING))\n     nextrlabel +=1\n     \n   if t2 !=\"R\":rindex +=1\n   if t2 !=\"L\":\n    if newrlist:\n     print(\"extending\",rlist,newrlist)\n     rlist.extend(newrlist)\n     print(\"extended\",rlist)\n     newrlist=[]\n     \n  rlist.sort(key=lambda x:x[\"bounds\"])\n  return rlist,nextrlabel\n  \n def compareintervals(currentoutcome,rlist1,rlist2):\n  for inner in rlist2:\n   if not rlist1:\n    if currentoutcome ==Position.CONTAINS:return Position.OVERLAPS\n    currentoutcome=Position.DISJOINT\n    \n   (start2,end2)=inner[\"bounds\"]\n   alldisjoint=True\n   for outer in rlist1:\n    if (inner[\"status\"],outer[\"status\"])in [(STARTING,ENDING),(ENDING,STARTING)]:continue\n    (start1,end1)=outer[\"bounds\"]\n    try :\n     position=inner[\"position\"][outer[\"ID\"]]\n     if position ==ABOVE and end1 >start2:return Position.OVERLAPS\n     elif position ==BELOW and start1 <end2:return Position.OVERLAPS\n     elif position ==CONTAINS:\n      if (start1 >start2 or end1 <end2):return Position.OVERLAPS\n      if outer[\"status\"]==ENDING and inner[\"status\"]!=ENDING:continue\n      alldisjoint=False\n     elif position ==ABOVEORCONTAINS:\n      if end1 <=start2:\n       if currentoutcome ==Position.CONTAINS:return Position.OVERLAPS\n       inner[\"position\"][outer[\"ID\"]]=ABOVE\n      elif start1 <=start2 and end1 >=end2:\n       if currentoutcome ==Position.DISJOINT:return Position.OVERLAPS\n       inner[\"position\"][outer[\"ID\"]]=CONTAINS\n       alldisjoint=False\n       currentoutcome=Position.CONTAINS\n      else :return Position.OVERLAPS\n     elif position ==BELOWORCONTAINS:\n      if start1 >=end2:\n       if currentoutcome ==Position.CONTAINS:return Position.OVERLAPS\n       inner[\"position\"][outer[\"ID\"]]=BELOW\n      elif start1 <=start2 and end1 >=end2:\n       if currentoutcome ==Position.DISJOINT:return Position.OVERLAPS\n       inner[\"position\"][outer[\"ID\"]]=CONTAINS\n       alldisjoint=False\n       currentoutcome=Position.CONTAINS\n      else :return Position.OVERLAPS\n      \n    except KeyError:\n     if start2 ==end2 ==start1 ==end1:\n      alldisjoint=False\n     elif start2 ==end2 ==end1:\n      inner[\"position\"][outer[\"ID\"]]=ABOVEORCONTAINS\n      alldisjoint=False\n     elif start2 ==end2 ==start1:\n      inner[\"position\"][outer[\"ID\"]]=BELOWORCONTAINS\n      alldisjoint=False\n     elif end1 <=start2:\n      inner[\"position\"][outer[\"ID\"]]=ABOVE\n     elif start1 >=end2:\n      inner[\"position\"][outer[\"ID\"]]=BELOW\n     elif start1 <=start2 and end1 >=end2:\n      if currentoutcome ==Position.DISJOINT:return Position.OVERLAPS\n      inner[\"position\"][outer[\"ID\"]]=CONTAINS\n      currentoutcome=Position.CONTAINS\n      if outer[\"status\"]==ENDING and inner[\"status\"]!=ENDING:continue\n      alldisjoint=False\n     else :\n      return Position.OVERLAPS\n   if alldisjoint:\n    if currentoutcome ==Position.CONTAINS:return Position.OVERLAPS\n    currentoutcome=Position.DISJOINT\n  return currentoutcome\n  \n dp1=dp+2\n poly1=getattr(poly1,\"pointList\",poly1)\n poly2=getattr(poly2,\"pointList\",poly2)\n poly1=[(round(x,dp1),round(y,dp1))for (x,y)in poly1]\n poly2=[(round(x,dp1),round(y,dp1))for (x,y)in poly2]\n transposed=False\n \n bboxresult=compareboundingboxes(poly1,poly2)\n if bboxresult ==Position.DISJOINT:return Position.DISJOINT\n if bboxresult ==Position.EQUAL:\n  if equalpolygons(poly1,poly2):return Position.EQUAL\n  elif polygonarea(poly2)>polygonarea(poly1):\n   poly1,poly2=poly2,poly1\n   transposed=True\n if bboxresult ==Position.INSIDE:\n  poly1,poly2=poly2,poly1\n  transposed=True\n  \n xvalues=sorted(set(x for (x,y)in poly1+poly2))\n print(poly1,poly2,xvalues)\n rlist1=[]\n rlist2=[]\n rdict={}\n nextrlabel1=65\n nextrlabel2=97\n currentoutcome=None\n for i,x in enumerate(xvalues):\n  intervals1=getintervals(poly1,x)\n  print(\"\\n\\nx-value\",x)\n  rlist1,nextrlabel1=getregions(intervals1,rlist1,nextrlabel1)\n  print(\"\\nrlist1\",rlist1)\n  intervals2=getintervals(poly2,x)\n  rlist2,nextrlabel2=getregions(intervals2,rlist2,nextrlabel2)\n  print(\"\\nrlist2\",rlist2)\n  \n  currentoutcome=compareintervals(currentoutcome,rlist1,rlist2)\n  \n  if currentoutcome ==Position.OVERLAPS:return currentoutcome\n if currentoutcome ==Position.CONTAINS and transposed:currentoutcome=Position.INSIDE\n return currentoutcome\n \n \n", []]}
__BRYTHON__.update_VFS(scripts)
